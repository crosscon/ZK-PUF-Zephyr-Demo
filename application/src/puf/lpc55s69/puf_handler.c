#include <zephyr/logging/log.h>
LOG_MODULE_DECLARE(PUF_VM);

#include <stdalign.h>
#include <stdio.h>
#include "puf_handler.h"
#include "fsl_puf.h"
#include "puf_prover.h"

#define PUF_KEY_SIZE PUF_RESPONSE_SIZE
#define PUF_KEY_CODE_SIZE PUF_GET_KEY_CODE_SIZE_FOR_KEY_SIZE(PUF_KEY_SIZE)

puf_config_t pufConfig;

/* These variables are global because while required to reconstruct PUF
 * they're not the PUF response on their own. Only the VM with access to
 * PUF can reconstruct it on the go and flush from memory after handling
 */

/* Placeholder data to be patched in flash after build */

__attribute__((section(".activation_code")))
__attribute__((used))
const uint8_t activation_code[PUF_ACTIVATION_CODE_SIZE] = { [0 ... PUF_ACTIVATION_CODE_SIZE-1] = 0x00 };

__attribute__((section(".key_code")))
__attribute__((used))
const uint8_t key_code[PUF_KEY_CODE_SIZE] = { [0 ... PUF_KEY_CODE_SIZE-1] = 0x00 };

TEE_Result init_puf(void)
{
    status_t status;

    status = _internal_puf_init();
    if (status != 0) return status;
    LOG_HEXDUMP_DBG(activation_code, PUF_ACTIVATION_CODE_SIZE, "Activation Code");

    status = _internal_puf_start(activation_code);
    if (status != 0) return status;

    LOG_HEXDUMP_DBG(key_code, PUF_KEY_CODE_SIZE, "Intrinsic key code");

    return TEE_SUCCESS;
}

/*
 * secure_memzero: overwrite a buffer with zeros in a way that
 * the compiler wonâ€™t optimize it away.
 */
static void secure_memzero(void *v, size_t n)
{
    volatile uint8_t *p = (volatile uint8_t *)v;
    while (n--) {
        *p++ = 0;
    }
}

int _internal_puf_init(void)
{
    status_t status;

    PUF_GetDefaultConfig(&pufConfig);
    status = PUF_Init(PUF, &pufConfig);
    if (status != kStatus_Success) {
        LOG_ERR("Error: PUF initialization failed!");
        return status;
    }
    LOG_INF("PUF Initialized Successfully.");
    return 0;
}

int _internal_puf_start(uint8_t *activation_code)
{
    status_t status;
    /* Start the PUF with the activation code */
    status = PUF_Start(PUF, activation_code, PUF_ACTIVATION_CODE_SIZE);
    if (status != kStatus_Success) {
        LOG_ERR("Error: PUF start failed!");
        return status;
    }
    LOG_INF("PUF Started successfully.");

    return 0;
}

TEE_Result puf_get_key(uint8_t *puf_key)
{
    status_t status;
    /* Reconstruct intrinsic key from keyCode1 generated by PUF_SetIntrinsicKey() */
    status = PUF_GetKey(PUF, key_code, PUF_KEY_CODE_SIZE, puf_key, PUF_KEY_SIZE);
    if (status != kStatus_Success)
    {
        LOG_ERR("Error: Failed reconstructing intrinsic key!");
        return TEE_ERROR_GENERIC;
    }
    return TEE_SUCCESS;
}

TEE_Result puf_flush_key(uint8_t *puf_key)
{
    /* Wipe the key material */
    secure_memzero(puf_key, PUF_KEY_SIZE);

    /* Verify the wipe */
    for (size_t i = 0; i < PUF_KEY_SIZE; i++) {
        if (puf_key[i] != 0) {
            /* some byte weren't cleared */
            return TEE_ERROR_CORRUPT_OBJECT;
        }
    }
    return TEE_SUCCESS;
}
