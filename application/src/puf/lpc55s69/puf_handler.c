#include <zephyr/logging/log.h>
LOG_MODULE_DECLARE(PUF_VM);

#include <stdalign.h>
#include <stdio.h>
#include "puf_handler.h"

/* These variables are global because while required to reconstruct PUF
 * they're not the PUF response on their own. Only the VM with access to
 * PUF can reconstruct it on the go and flush from memory after handling
 */
alignas(4) uint8_t activation_code[PUF_ACTIVATION_CODE_SIZE];
alignas(4) uint8_t key_code[PUF_KEY_CODE_SIZE];

puf_config_t pufConfig;

int init_puf(void)
{
    status_t status;

    status = inner_puf_init();
    if (status != 0) return status;

    if (GENERATE_PUF_STUFF) {
        status = inner_puf_create_ac(activation_code);
        if (status != 0) return status;
    } else {
        memcpy(activation_code, hardcoded_activation_code, PUF_ACTIVATION_CODE_SIZE);
    }

    status = inner_puf_start(activation_code);
    if (status != 0) return status;

    if (GENERATE_PUF_STUFF) {
        status = inner_puf_create_intrinsic_keycode(key_code);
        if (status != 0) return status;
    } else {
        memcpy(key_code, hardcoded_key_code, PUF_KEY_CODE_SIZE);
    }

    return 0;
}

/*
 * secure_memzero: overwrite a buffer with zeros in a way that
 * the compiler wonâ€™t optimize it away.
 */
static void secure_memzero(void *v, size_t n)
{
    volatile uint8_t *p = (volatile uint8_t *)v;
    while (n--) {
        *p++ = 0;
    }
}

int inner_puf_init(void)
{
    status_t status;

    PUF_GetDefaultConfig(&pufConfig);
    status = PUF_Init(PUF, &pufConfig);
    if (status != kStatus_Success) {
        LOG_ERR("Error: PUF initialization failed!");
        return status;
    }
    LOG_INF("PUF Initialized Successfully.");
    return 0;
}

int inner_puf_create_ac(uint8_t *activation_code)
{
    status_t status;
    memset(activation_code, 0, PUF_ACTIVATION_CODE_SIZE);
    status = PUF_Enroll(PUF, activation_code, PUF_ACTIVATION_CODE_SIZE);

    if (status != kStatus_Success) {
        LOG_ERR("Error: PUF enrollment failed!");
        return status;
    }

    LOG_INF("PUF Enroll successful. Activation Code created.");

    LOG_HEXDUMP_DBG(activation_code, PUF_ACTIVATION_CODE_SIZE, "Activation Code");

    PUF_Deinit(PUF, &pufConfig);
    status = PUF_Init(PUF, &pufConfig);
    if (status != kStatus_Success) {
        LOG_ERR("Error: PUF reinitialization after enrollment failed!");
        return status;
    }
    LOG_INF("PUF Reinitialized after enrollment.");

    return 0;
}

int inner_puf_start(uint8_t *activation_code)
{
    status_t status;
    /* Start the PUF with the activation code */
    status = PUF_Start(PUF, activation_code, PUF_ACTIVATION_CODE_SIZE);
    if (status != kStatus_Success) {
        LOG_ERR("Error: PUF start failed!");
        return status;
    }
    LOG_INF("PUF Started successfully.");

    return 0;
}

int inner_puf_create_intrinsic_keycode(uint8_t *key_code)
{
    status_t status;
    status = PUF_SetIntrinsicKey(PUF, kPUF_KeyIndex_01, PUF_KEY_SIZE, key_code, PUF_KEY_CODE_SIZE);
    if (status != kStatus_Success) {
        LOG_ERR("Error: PUF Intrinsic key 1 generation failed!");
        return status;
    }

    LOG_HEXDUMP_DBG(key_code, PUF_KEY_CODE_SIZE, "Intrinsic key code");

    return 0;
}

int puf_get_key(uint8_t *puf_key)
{
    status_t status;
    /* Reconstruct intrinsic key from keyCode1 generated by PUF_SetIntrinsicKey() */
    status = PUF_GetKey(PUF, key_code, PUF_KEY_CODE_SIZE, puf_key, PUF_KEY_SIZE);
    if (status != kStatus_Success)
    {
        LOG_ERR("Error: Failed reconstructing intrinsic key!");
        return status;
    }
    return 0;
}

int puf_flush_key(uint8_t *puf_key)
{
    /* Wipe the key material */
    secure_memzero(puf_key, PUF_KEY_SIZE);

    /* Verify the wipe */
    for (size_t i = 0; i < PUF_KEY_SIZE; i++) {
        if (puf_key[i] != 0) {
            /* some byte weren't cleared */
            return -1;
        }
    }
    return 0;
}
