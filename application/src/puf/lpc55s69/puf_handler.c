#include <stdalign.h>
#include <stdio.h>
#include "puf_handler.h"
#include "flash_handler.h"

/* These variables are global because while required to reconstruct PUF
 * they're not the PUF response on their own. Only the VM with access to
 * PUF can reconstruct it on the go and flush from memory after handling
 */
alignas(4) uint8_t activation_code[PUF_ACTIVATION_CODE_SIZE];
alignas(4) uint8_t key_code[PUF_KEY_CODE_SIZE];

puf_config_t pufConfig;

int init_puf(void)
{
    status_t status;

    status = inner_puf_init();
    if (status != 0) return status;

    if (GENERATE_PUF_STUFF) {
        status = inner_puf_create_ac(activation_code);
        if (status != 0) return status;
    } else {
        memcpy(activation_code, hardcoded_activation_code, PUF_ACTIVATION_CODE_SIZE);
    }

    status = inner_puf_start(activation_code);
    if (status != 0) return status;

    if (GENERATE_PUF_STUFF) {
        status = inner_puf_create_intrinsic_keycode(key_code);
        if (status != 0) return status;
    } else {
        memcpy(key_code, hardcoded_key_code, PUF_KEY_CODE_SIZE);
    }

    return 0;
}

/*
 * secure_memzero: overwrite a buffer with zeros in a way that
 * the compiler wonâ€™t optimize it away.
 */
static void secure_memzero(void *v, size_t n)
{
    volatile uint8_t *p = (volatile uint8_t *)v;
    while (n--) {
        *p++ = 0;
    }
}

int inner_puf_init(void)
{
    status_t status;

    PUF_GetDefaultConfig(&pufConfig);
    status = PUF_Init(PUF, &pufConfig);
    if (status != kStatus_Success) {
        printf("Error: PUF initialization failed!\r\n");
        return status;
    }
    printf("PUF Initialized Successfully.\r\n");
    return 0;
}

int inner_puf_create_ac(uint8_t *activation_code)
{
    status_t status;
    memset(activation_code, 0, PUF_ACTIVATION_CODE_SIZE);
    status = PUF_Enroll(PUF, activation_code, PUF_ACTIVATION_CODE_SIZE);

    if (status != kStatus_Success) {
        printf("\r\n%d %d\r\n", status, kStatus_Success);
        printf("Error: PUF enrollment failed!\r\n");
        return status;
    }

    printf("PUF Enroll successful. Activation Code created.\r\n");

    printf("Activation Code: ");
    for (int i = 0; i < PUF_ACTIVATION_CODE_SIZE; i++) {
        printf("%02X", activation_code[i]);
    }
    printf("\r\n");

    PUF_Deinit(PUF, &pufConfig);
    status = PUF_Init(PUF, &pufConfig);
    if (status != kStatus_Success) {
        printf("Error: PUF reinitialization after enrollment failed!\r\n");
        return status;
    }
    printf("PUF Reinitialized after enrollment.\r\n");

    return 0;
}

int inner_puf_start(uint8_t *activation_code)
{
    status_t status;
    /* Start the PUF with the activation code */
    status = PUF_Start(PUF, activation_code, PUF_ACTIVATION_CODE_SIZE);
    if (status != kStatus_Success) {
        printf("Error: PUF start failed!\r\n");
        return status;
    }
    printf("PUF Started successfully.\r\n");

    return 0;
}

int inner_puf_create_intrinsic_keycode(uint8_t *key_code)
{
    status_t status;
    status = PUF_SetIntrinsicKey(PUF, kPUF_KeyIndex_01, PUF_KEY_SIZE, key_code, PUF_KEY_CODE_SIZE);
    if (status != kStatus_Success) {
        printf("PUF Intrinsic key 1 generation failed!\r\n");
        printf("%d\r\n", status);
        return status;
    }

    printf("Intrinsic key code = \r\n");
    for (int i = 0; i < PUF_KEY_CODE_SIZE; i++)
    {
        printf("%02X", key_code[i]);
    }

    printf("\r\n");

    return 0;
}

int puf_get_key(uint8_t *puf_key)
{
    status_t status;
    /* Reconstruct intrinsic key from keyCode1 generated by PUF_SetIntrinsicKey() */
    status = PUF_GetKey(PUF, key_code, PUF_KEY_CODE_SIZE, puf_key, PUF_KEY_SIZE);
    if (status != kStatus_Success)
    {
        printf("Error reconstructing intrinsic key!\r\n");
    }
}

int puf_flush_key(uint8_t *puf_key)
{
    /* Wipe the key material */
    secure_memzero(puf_key, PUF_KEY_SIZE);

    /* Verify the wipe */
    for (size_t i = 0; i < PUF_KEY_SIZE; i++) {
        if (puf_key[i] != 0) {
            /* some byte weren't cleared */
            return -1;
        }
    }
}
