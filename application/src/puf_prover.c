#include <stdio.h>
#include "puf_prover.h"
#include "flash_handler.h"
#include "mbedtls/bignum.h"
#include "mbedtls/ctr_drbg.h"
#include "mbedtls/entropy.h"
#include "mbedtls/ecp.h"
#include <stddef.h>
#include "mbedtls/sha256.h"


int PUF_Prover_Initialize(PUF_Type *puf,
                          uint8_t *activation_code,
                          size_t activation_code_size,
                          const struct flash_area *flash_area,
                          const struct device *flash_dev,
                          bool writeToFlash)
{
    status_t status;
    puf_config_t pufConfig;
    int ret;

    /* Get default configuration and initialize the provided PUF instance */
    PUF_GetDefaultConfig(&pufConfig);
    status = PUF_Init(puf, &pufConfig);
    if (status != kStatus_Success) {
        printf("Error: PUF initialization failed!\r\n");
        return -1;
    }
    printf("PUF Initialized Successfully.\r\n");

    if (writeToFlash) {
        /* Enroll and generate the activation code */
        memset(activation_code, 0, activation_code_size);
        status = PUF_Enroll(puf, activation_code, activation_code_size);
        if (status != kStatus_Success) {
            printf("Error: PUF enrollment failed!\r\n");
            flash_area_close(flash_area);
            return -1;
        }
        printf("PUF Enroll successful. Activation Code created.\r\n");

        /* Write the activation code to flash with padding */
        ret = flash_write_padded(flash_dev, flash_area, FLASH_OFFSET_ACTIVATION_CODE,
                                 activation_code, activation_code_size);
        if (ret != 0) {
            flash_area_close(flash_area);
            return -1;
        }
        printf("Activation code saved in flash.\r\n");

        /* Reinitialize PUF after enrollment */
        PUF_Deinit(puf, &pufConfig);
        PUF_Init(puf, &pufConfig);
        printf("PUF Reinitialized after enrollment.\r\n");
    } else {
        /* Read the activation code from flash */
        ret = flash_read_data(flash_dev, flash_area, FLASH_OFFSET_ACTIVATION_CODE,
                              activation_code, activation_code_size);
        if (ret != 0) {
            flash_area_close(flash_area);
            return -1;
        }
        printf("Activation code read from flash.\r\n");
    }

    /* Start the PUF with the activation code */
    status = PUF_Start(puf, activation_code, activation_code_size);
    if (status != kStatus_Success) {
        printf("Error: PUF start failed!\r\n");
        return -1;
    }
    printf("PUF Started successfully.\r\n");

    uint8_t keyCode[PUF_KEY_CODE_SIZE] = {0};
    uint8_t intrinsicKey[PUF_KEY_SIZE] = {0};

    if (writeToFlash) {

        ret = PUF_SetIntrinsicKey(PUF, kPUF_KeyIndex_01, PUF_KEY_SIZE, keyCode, sizeof(keyCode));
        if (ret != 0) {
            printf("PUF Intrinsic key 1 generation failed!\r\n");
            return ret;
        }

        ret = flash_write_padded(flash_dev, flash_area, FLASH_OFFSET_INTRINSIC_KEY_1_KC,
                                 keyCode, PUF_KEY_CODE_SIZE);
        if (ret != 0) {
            printf("PUF Intrinsic key 1 KC saving to flash failed!\r\n");
            return ret;

        }
    } else {
        ret = flash_read_data(flash_dev, flash_area, FLASH_OFFSET_INTRINSIC_KEY_1_KC,
                              keyCode, PUF_KEY_CODE_SIZE);
        if (ret != 0) {
            flash_area_close(flash_area);
            return -1;
        }
        printf("Intrinsic key code read from flash.\r\n");
    }

    printf("Intrinsic key code = \r\n");
    for (int i = 0; i < PUF_KEY_CODE_SIZE; i++)
    {
        printf("%x ", keyCode[i]);
    }
    printf("\r\n");
    /* Reconstruct intrinsic key from keyCode1 generated by PUF_SetIntrinsicKey() */
    ret = PUF_GetKey(PUF, keyCode, sizeof(keyCode), intrinsicKey, sizeof(intrinsicKey));
    if (ret != kStatus_Success)
    {
        printf("Error reconstructing intrinsic key!\r\n");
    }

    printf("Reconstructed intrinsic key = ");
    for (int i = 0; i < PUF_KEY_SIZE; i++)
    {
        printf("%x ", intrinsicKey[i]);
    }
    printf("\r\n");

    flash_area_close(flash_area);

    return 0;
}



int initializeAndStartPuf(PUF_Type *puf,puf_config_t pufConfig,
                          uint8_t *activation_code,
                          size_t activation_code_size,
                          const struct flash_area *flash_area,
                          const struct device *flash_dev,
                          bool writeToFlash){
    status_t status;
    int ret;

    /* Get default configuration and initialize the provided PUF instance */
    PUF_GetDefaultConfig(&pufConfig);
    status = PUF_Init(puf, &pufConfig);
    if (status != kStatus_Success) {
        printf("Error: PUF initialization failed!\r\n");
        return -1;
    }
    printf("PUF Initialized Successfully.\r\n");

    if (writeToFlash) {
        /* Enroll and generate the activation code */
        memset(activation_code, 0, activation_code_size);
        status = PUF_Enroll(puf, activation_code, activation_code_size);
        if (status != kStatus_Success) {
            printf("Error: PUF enrollment failed!\r\n");
            flash_area_close(flash_area);
            return -1;
        }
        printf("PUF Enroll successful. Activation Code created.\r\n");

        /* Write the activation code to flash with padding */
        ret = flash_write_padded(flash_dev, flash_area, FLASH_OFFSET_ACTIVATION_CODE,
                                 activation_code, activation_code_size);
        if (ret != 0) {
            flash_area_close(flash_area);
            return -1;
        }
        printf("Activation code saved in flash.\r\n");

        /* Reinitialize PUF after enrollment */
        PUF_Deinit(puf, &pufConfig);
        PUF_Init(puf, &pufConfig);
        printf("PUF Reinitialized after enrollment.\r\n");
    } else {
        /* Read the activation code from flash */
        ret = flash_read_data(flash_dev, flash_area, FLASH_OFFSET_ACTIVATION_CODE,
                              activation_code, activation_code_size);
        if (ret != 0) {
            flash_area_close(flash_area);
            return -1;
        }
        printf("Activation code read from flash.\r\n");
    }

    /* Start the PUF with the activation code */
    status = PUF_Start(puf, activation_code, activation_code_size);
    if (status != kStatus_Success) {
        printf("Error: PUF start failed!\r\n");
        return -1;
    }
    printf("PUF Started successfully.\r\n");

    return 0;
}


int getPufKey(PUF_Type *puf,
                          uint8_t *activation_code,
                          size_t activation_code_size,
                          const struct flash_area *flash_area,
                          const struct device *flash_dev,
                          bool writeToFlash,uint8_t pufSlot,
                          uint8_t *outputBuffer)
{
    
    uint8_t keyCode[PUF_KEY_CODE_SIZE] = {0};
    uint8_t intrinsicKey[PUF_KEY_SIZE] = {0};
    int ret;
    
    if (writeToFlash) {

        ret = PUF_SetIntrinsicKey(PUF, kPUF_KeyIndex_01, PUF_KEY_SIZE, keyCode, sizeof(keyCode));
        if (ret != 0) {
            printf("PUF Intrinsic key 1 generation failed!\r\n");
            return ret;
        }

        ret = flash_write_padded(flash_dev, flash_area, (pufSlot == 0) ? FLASH_OFFSET_INTRINSIC_KEY_1_KC : FLASH_OFFSET_INTRINSIC_KEY_2_KC,
                                 keyCode, PUF_KEY_CODE_SIZE);
        if (ret != 0) {
            printf("PUF Intrinsic key 1 KC saving to flash failed!\r\n");
            return ret;

        }
    } else {
        ret = flash_read_data(flash_dev, flash_area, (pufSlot == 0) ? FLASH_OFFSET_INTRINSIC_KEY_1_KC : FLASH_OFFSET_INTRINSIC_KEY_2_KC ,
                              keyCode, PUF_KEY_CODE_SIZE);
        if (ret != 0) {
            flash_area_close(flash_area);
            return -1;
        }
        printf("Intrinsic key code read from flash.\r\n");
    }

    /* Reconstruct intrinsic key from keyCode1 generated by PUF_SetIntrinsicKey() */
    ret = PUF_GetKey(PUF, keyCode, sizeof(keyCode), intrinsicKey, sizeof(intrinsicKey));
    if (ret != kStatus_Success)
    {
        printf("Error reconstructing intrinsic key!\r\n");
    }

    if (outputBuffer != NULL) {
        memcpy(outputBuffer, intrinsicKey, PUF_KEY_SIZE);
    }
    
    flash_area_close(flash_area);

    return 0;
}

void pufDeinit(PUF_Type *puf,puf_config_t pufConfig){
    PUF_Deinit(puf, &pufConfig);
}

int getResponseToChallenge(const uint8_t *c, size_t c_size, mbedtls_mpi *r, PUF_Type *puf,
                          uint8_t *activation_code,
                          size_t activation_code_size,
                          const struct flash_area *flash_area,
                          const struct device *flash_dev,
                          bool writeToFlash,int pufSlot
                          ){
    
    int ret;
    uint8_t keysize = PUF_KEY_SIZE;
    uint8_t *key = malloc(keysize);
    uint8_t *hashOutput = malloc(keysize);

    ret = getPufKey(puf,activation_code,activation_code_size,
                          flash_area,flash_dev,
                          writeToFlash,pufSlot,
                          key);

    if(ret!=0){
        printf("Error While Getting Response From PUF");
        return ret;
    }

    

    uint8_t combined[c_size + keysize];

    // Combine keyCode and challenge
    memcpy(combined, key, keysize);
    memcpy(combined + keysize, c, c_size);

    printf("Intrinsic key = ");
    for (int i = 0; i < PUF_KEY_SIZE; i++)
    {
        printf("%x ", key[i]);
    }
    printf("\r\n");
   
    // Hash the combined data
    mbedtls_sha256(combined, sizeof(combined), hashOutput, 0);
    
    printf("Hashed Output = ");
    for (int i = 0; i < PUF_KEY_SIZE; i++)
    {
        printf("%x ", hashOutput[i]);
    }
    printf("\r\n");

    if (mbedtls_mpi_read_binary(r, hashOutput, PUF_KEY_SIZE) != 0) {
        free(hashOutput);
        free(key);
    	return 1;
    }



    free(hashOutput);
    free(key);

    return 0;
}

int randFunction(void *rng_state, unsigned char *output, size_t len) {
	
    printf("Heeloo from rand");
    size_t use_len;
	int rnd;
    
	if (rng_state != NULL)
		rng_state = NULL;

	while (len > 0) {
		use_len = len;
		if (use_len > sizeof(int))
			use_len = sizeof(int);

		rnd = rand();
		memcpy(output, &rnd, use_len);
		output += use_len;
		len -= use_len;
	}

    
	return (0);
}

int performEnrollment(mbedtls_ecp_group *grp, mbedtls_ecp_point *h, mbedtls_ecp_point *C , const uint8_t *c1, size_t c1_size, const uint8_t *c2, size_t c2_size , 
                          PUF_Type *puf,
                          uint8_t *activation_code,
                          size_t activation_code_size,
                          const struct flash_area *flash_area,
                          const struct device *flash_dev,
                          bool writeToFlash){
    
    printf("Enrollement Started\r\n");
    mbedtls_ecp_group_init(grp);
	mbedtls_ecp_point_init(h);
	mbedtls_ecp_point_init(C);
	int res;
	res = mbedtls_ecp_group_load(grp, MBEDTLS_ECP_DP_SECP256R1);
	
    if (res != 0) {
        printf("Failed to load EC group: -0x%04X\n", -res);
        return 1;
    }

    mbedtls_mpi x;
	mbedtls_mpi_init(&x);
	res = mbedtls_mpi_lset(&x, CONSTANT_FOR_H_GENERATOR);  
	
     if (res != 0) {
        printf("Failed to set X");
        return 1;
    }
    
    res = mbedtls_ecp_mul(grp, h, &x, &grp->G, randFunction, NULL);
    
    if (res != 0) {
        printf("Failed to generate h point: %d\n", res);
        return 1;
    }

	mbedtls_mpi mpiValue_R1, mpiValue_R2;
	mbedtls_mpi_init(&mpiValue_R1);
	mbedtls_mpi_init(&mpiValue_R2);

	if (getResponseToChallenge(c1,c1_size,&mpiValue_R1,puf,activation_code,
                          activation_code_size,
                          flash_area,
                          flash_dev,
                          writeToFlash,PUF_SLOT_0) != 0) {
		return 1;
	}

	if (getResponseToChallenge(c2,c2_size,&mpiValue_R2,puf,activation_code,
                          activation_code_size,
                          flash_area,
                          flash_dev,
                          writeToFlash,PUF_SLOT_1) != 0) {
		return 1;
	}
    
	if(mbedtls_ecp_muladd(grp, C, &mpiValue_R1, &grp->G, &mpiValue_R2, h) != 0) { // C = g * R1 + h * R2
		return 1;
	}

	return 0;

}





