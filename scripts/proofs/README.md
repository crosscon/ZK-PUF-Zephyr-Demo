# Verifier Proof scripts

This repository contains 2 scripts that were developed with
[SageMath](https://www.sagemath.org/) that allow for working and debugging the
verification process of the Zero Knowledge PUF scheme provided within the
CROSSCON Project:

- [`proof_verifier_calc.sage`](./proof_verifier_calc.sage)
- [`proof_full_calc.sage`](./proof_full_calc.sage)

Both of these scripts can be run with:

```sh
sage <script>
```
## Verification

The full verification follows the equation:

$$
g^v \cdot h^w = g^{r+\alpha R1} \cdot h^{r+\alpha R1} = g^r \cdot g^{\alpha R1} \cdot h^u \cdot h^{\alpha R2} = P \cdot (g^{R_1} \cdot h^{R_2})^{\alpha} = P \cdot \textit{COM}^{\alpha}
$$

This verification process guarantees the verifier that the prover indeed holds the two PUF
responses, R1 and R2, and further ensures the session’s freshness. For the zero-knowledge
proofs v and w to be validated, the prover is required to use the same α as the verifier,
thereby incorporating the nonce n. This mechanism ensures the uniqueness and security
of each session, effectively preventing replay attacks.

## `proof_verifier_calc`

This script follows the above equation and can be used to authenticate the device
using the information sent over by a prover which are:

- **Public data generated during device enrollment**
    - $g$
    - $h$
    - $\textit{COM}$
- **Data sent over during authentication**
    - $P$
    - $v$
    - $w$
- **Data sent over by verifier during authentication to ensure freshness of response**
    - $n$

It can be used either in an interactive mode via `-i` flag where each value
gets prompted for or in CLI mode where it acts as a script.

```sh
$ sage proof_verifier_calc.sage \
-gx 48439561293906451759052585252797914202762949526041747995844080717082404635286 \
-gy 36134250956749795798585127919587881956611106672985015071877198253568414405109 \
-hx 113672263116997988963422843336732598436413491673093427510593090874115734366920 \
-hy 72128700264312800745139615838618004912179104417622320868058732335103630931058 \
-COMx 108887395517555711213571193942801202590603000163278169781676396049150358668394 \
-COMy 106368966609063898045629657484452456077590894981651239632791818523735593646804 \
-Px 111197063520486627773327379133483657248037021466728584828985029675018465946326 \
-Py 67841034900616992448703157583029835596137519082578692896601832903935578025304 \
-v 384137556070151706204726925341987532315253034831419395846847553925216928043725690742685425836638679299220350167232811992208757506380805029151774990425871 \
-w 3404531363088144633282987593955524786906878361029335119950302783608839743412537535357054994867504646095720921918002433618637456153044922020374904677741060 \
-n 226943873990931286441454800825694102067

Step 1: Define secp256r1 curve (P-256)...
Curve defined over F_p with equation: y^2 = x^3 + ax + b

=== Zero Knowledge Verifier Proof Tool (CLI Mode) ===

Step 2: g = E((0x6b17d1f2e12c4247f8bce6e563a440f277037d812deb33a0f4a13945d898c296, 0x4fe342e2fe1a7f9b8ee7eb4a7c0f9e162bce33576b315ececbb6406837bf51f5)) -> (48439561293906451759052585252797914202762949526041747995844080717082404635286 : 36134250956749795798585127919587881956611106672985015071877198253568414405109 : 1)
h = E((0xfb50388f29498d0a93ad25ec4c34037b9d3cc3cca4787eb6fedabe2b3003eac8, 0x9f7765ca9d6288e6ff734f5cd08f3a5921cf54b21bb398b50ac0d2577fa07472)) -> (113672263116997988963422843336732598436413491673093427510593090874115734366920 : 72128700264312800745139615838618004912179104417622320868058732335103630931058 : 1)

Step 3: COM = E((0xf0bc14f3dc4ac70639433b4337f9312c88f7b0cd2d3c705b53543882c3e9446a, 0xeb2ab39be2d403c51ebd68923b629006d4ae0105fef906dd7cbcc8468c44fad4)) -> (108887395517555711213571193942801202590603000163278169781676396049150358668394 : 106368966609063898045629657484452456077590894981651239632791818523735593646804 : 1)

Step 4: nonce = 0xaabbccddeeffaabbccddeeff00112233

Step 5: P = E((0xf5d74ebf7c561b9f282c87924c5240c70af354c2474f727c0558f7564ba1aad6, 0x95fcaa3f39437688c6a4f9a4ca2464af76b88abf6edae6079b46c1c019eb2d58)) -> (111197063520486627773327379133483657248037021466728584828985029675018465946326 : 67841034900616992448703157583029835596137519082578692896601832903935578025304 : 1)

Step 6: v = 0x755a0112843840a4622f34cc1a1107eaf7c58deb9502f632a3420d1dd9cc1e63063d9ad3f225619fd6f343c1d4d1be50cbc3356d3d586f9c86824949dd45f0f, w = 0x410100ae3fe01001a46bfcb3726e4a842589e4ec6b1ee292d606f21fa49e8ce5941327afb009b69829eca3f03f7c589b750060ca069405b56dfedf81064e3204


Step 7: Reconstruct raw P.x||P.y as hex
P (hex) = F5D74EBF7C561B9F282C87924C5240C70AF354C2474F727C0558F7564BA1AAD695FCAA3F39437688C6A4F9A4CA2464AF76B88ABF6EDAE6079B46C1C019EB2D58

Step 8: Reconstruct raw 16-byte n as hex
n (hex) = AABBCCDDEEFFAABBCCDDEEFF00112233

Step 9: Preimage (P || nonce) as hex:
F5D74EBF7C561B9F282C87924C5240C70AF354C2474F727C0558F7564BA1AAD695FCAA3F39437688C6A4F9A4CA2464AF76B88ABF6EDAE6079B46C1C019EB2D58AABBCCDDEEFFAABBCCDDEEFF00112233

Step 10: Compute α = H(P, n)
α (as hex) = BECC1C11BF56E54F0AFFA940F8995DE712AB1F34BAE163F52F88C0C1DBD63075
α (as integer) = 86300071759402602213163195561903351300107941739038348936801687322805015031925

Step 11: Check if g^v*h^w=P*COM^α
g^v * h^w = (35347418311403680825182024519718896354483624071558176385618176411353842517945 : 39605327952754738806247145381509600727109982487968243672618485269037264660729 : 1)
P * COM^α = (35347418311403680825182024519718896354483624071558176385618176411353842517945 : 39605327952754738806247145381509600727109982487968243672618485269037264660729 : 1)
✅ Proof verifies: g^v·h^w = P·COM^α
Computation complete
```

```sh
$ sage proof_verifier_calc.sage -i

Step 1: Define secp256r1 curve (P-256)...
Curve defined over F_p with equation: y^2 = x^3 + ax + b

=== Zero Knowledge Verifier Proof Tool (Interactive Mode) ===

Step 2: Input coordinates for g and h (decimal or hex with 0x prefix)
Enter g_x: 48439561293906451759052585252797914202762949526041747995844080717082404635286
Enter g_y: 36134250956749795798585127919587881956611106672985015071877198253568414405109
g = E((0x6b17d1f2e12c4247f8bce6e563a440f277037d812deb33a0f4a13945d898c296, 0x4fe342e2fe1a7f9b8ee7eb4a7c0f9e162bce33576b315ececbb6406837bf51f5)) -> (48439561293906451759052585252797914202762949526041747995844080717082404635286 : 36134250956749795798585127919587881956611106672985015071877198253568414405109 : 1)
Enter h_x: 113672263116997988963422843336732598436413491673093427510593090874115734366920
Enter h_y: 72128700264312800745139615838618004912179104417622320868058732335103630931058
h = E((0xfb50388f29498d0a93ad25ec4c34037b9d3cc3cca4787eb6fedabe2b3003eac8, 0x9f7765ca9d6288e6ff734f5cd08f3a5921cf54b21bb398b50ac0d2577fa07472)) -> (113672263116997988963422843336732598436413491673093427510593090874115734366920 : 72128700264312800745139615838618004912179104417622320868058732335103630931058 : 1)

Step 3: Input coordinates for COM (decimal or hex with 0x prefix)
Enter COM_x: 108887395517555711213571193942801202590603000163278169781676396049150358668394
Enter COM_y: 106368966609063898045629657484452456077590894981651239632791818523735593646804
COM = E((0xf0bc14f3dc4ac70639433b4337f9312c88f7b0cd2d3c705b53543882c3e9446a, 0xeb2ab39be2d403c51ebd68923b629006d4ae0105fef906dd7cbcc8468c44fad4)) -> (108887395517555711213571193942801202590603000163278169781676396049150358668394 : 106368966609063898045629657484452456077590894981651239632791818523735593646804 : 1)

Step 4: Enter scalar nonce (decimal or hex with 0x prefix)
Enter nonce: 226943873990931286441454800825694102067
nonce = 0xaabbccddeeffaabbccddeeff00112233

Step 5: Input coordinates for P (decimal or hex with 0x prefix)
Enter P_x: 111197063520486627773327379133483657248037021466728584828985029675018465946326
Enter P_y: 67841034900616992448703157583029835596137519082578692896601832903935578025304
P = E((0xf5d74ebf7c561b9f282c87924c5240c70af354c2474f727c0558f7564ba1aad6, 0x95fcaa3f39437688c6a4f9a4ca2464af76b88abf6edae6079b46c1c019eb2d58)) -> (111197063520486627773327379133483657248037021466728584828985029675018465946326 : 67841034900616992448703157583029835596137519082578692896601832903935578025304 : 1)

Step 6: Enter scalars v and w (decimal or hex with 0x prefix)
Enter v: 384137556070151706204726925341987532315253034831419395846847553925216928043725690742685425836638679299220350167232811992208757506380805029151774990425871
Enter w: 3404531363088144633282987593955524786906878361029335119950302783608839743412537535357054994867504646095720921918002433618637456153044922020374904677741060
v = 0x755a0112843840a4622f34cc1a1107eaf7c58deb9502f632a3420d1dd9cc1e63063d9ad3f225619fd6f343c1d4d1be50cbc3356d3d586f9c86824949dd45f0f, w = 0x410100ae3fe01001a46bfcb3726e4a842589e4ec6b1ee292d606f21fa49e8ce5941327afb009b69829eca3f03f7c589b750060ca069405b56dfedf81064e3204


Step 7: Reconstruct raw P.x||P.y as hex
P (hex) = F5D74EBF7C561B9F282C87924C5240C70AF354C2474F727C0558F7564BA1AAD695FCAA3F39437688C6A4F9A4CA2464AF76B88ABF6EDAE6079B46C1C019EB2D58

Step 8: Reconstruct raw 16-byte n as hex
n (hex) = AABBCCDDEEFFAABBCCDDEEFF00112233

Step 9: Preimage (P || nonce) as hex:
F5D74EBF7C561B9F282C87924C5240C70AF354C2474F727C0558F7564BA1AAD695FCAA3F39437688C6A4F9A4CA2464AF76B88ABF6EDAE6079B46C1C019EB2D58AABBCCDDEEFFAABBCCDDEEFF00112233

Step 10: Compute α = H(P, n)
α (as hex) = BECC1C11BF56E54F0AFFA940F8995DE712AB1F34BAE163F52F88C0C1DBD63075
α (as integer) = 86300071759402602213163195561903351300107941739038348936801687322805015031925

Step 11: Check if g^v*h^w=P*COM^α
g^v * h^w = (35347418311403680825182024519718896354483624071558176385618176411353842517945 : 39605327952754738806247145381509600727109982487968243672618485269037264660729 : 1)
P * COM^α = (35347418311403680825182024519718896354483624071558176385618176411353842517945 : 39605327952754738806247145381509600727109982487968243672618485269037264660729 : 1)
✅ Proof verifies: g^v·h^w = P·COM^α
Computation complete
```

## `proof_full_calc.sage`

This script is aimed for development/debugging and calculates every variable
used within the proof. The user needs to manually parse $g$, $h$, $R_1$, $R_2$,
$r$, $u$ and $n$.
